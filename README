Basic implementation of plugin architecture in C++

- plugins comply with a basic API:
  - libname.so should expose createName and destroyName
  - these should return a pointer to a `new` Name and destroy an existing
    Name object, respectively
  - Names should also implement makeSound
- plugins can be added to the designated plugin directory while zoo is
  running
- plugins can be picked up and run on the fly if added

Ultimately, this forms the basic premise for plugin-based implementation of
workflow nodes

.
├── build
│   └── plugins               directory for installed plugins
├── CMakeLists.txt
├── ext_plugins               directory for external (user defined) plugins
│   ├── cow.o
│   ├── plugins
│   │   ├── libcow.so
│   │   └── libzebra.so
│   ├── README                build instructions for external plugins
│   ├── src                   user-defined plugin sources
│   │   ├── cow.cpp
│   │   ├── cow.h
│   │   ├── zebra.cpp
│   │   └── zebra.h
│   └── zebra.o
├── include                   main include directory
│   └── animal.h              base abstract plugin class definition
├── plugins                   derived plugin class sources shipped with repo
│   ├── cat.cpp
│   ├── cat.h
│   ├── CMakeLists.txt        builds .so files for each derived plugin
│   ├── dog.cpp
│   ├── dog.h
│   ├── tiger.cpp
│   └── tiger.h
├── README                    this file
└── src                       main repo source
    ├── util                  utilities
    │   ├── globothy.cpp      glob files, used to find .so files
    │   ├── globothy.h
    │   ├── libnameothy.cpp   extract lib name from .so files
    │   └── libnameothy.h
    └── zoo.cpp               main(), runs two threads to find/call plugins
